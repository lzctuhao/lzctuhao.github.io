this.workbox=this.workbox||{};this.workbox.routing=function(e,t,r,o,s){"use strict";try{self["workbox:routing:5.1.2"]&&_()}catch(e){}const a="GET";const n=["DELETE","GET","HEAD","PATCH","POST","PUT"];const i=e=>{if(e&&typeof e==="object"){{t.assert.hasMethod(e,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"})}return e}else{{t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"})}return{handle:e}}};class u{constructor(e,r,o=a){{t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"});if(o){t.assert.isOneOf(o,n,{paramName:"method"})}}this.handler=i(r);this.match=e;this.method=o}}class l extends u{constructor(e,{allowlist:r=[/./],denylist:o=[]}={}){{t.assert.isArrayOfClass(r,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.allowlist"});t.assert.isArrayOfClass(o,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.denylist"})}super((e=>this._match(e)),e);this._allowlist=r;this._denylist=o}_match({url:e,request:t}){if(t&&t.mode!=="navigate"){return false}const o=e.pathname+e.search;for(const e of this._denylist){if(e.test(o)){{r.logger.log(`The navigation route ${o} is not `+`being used, since the URL matches this denylist pattern: `+`${e}`)}return false}}if(this._allowlist.some((e=>e.test(o)))){{r.logger.debug(`The navigation route ${o} `+`is being used.`)}return true}{r.logger.log(`The navigation route ${o} is not `+`being used, since the URL being navigated to doesn't `+`match the allowlist.`)}return false}}class c extends u{constructor(e,o,s){{t.assert.isInstance(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"})}const a=({url:t})=>{const o=e.exec(t.href);if(!o){return}if(t.origin!==location.origin&&o.index!==0){{r.logger.debug(`The regular expression '${e}' only partially matched `+`against the cross-origin URL '${t}'. RegExpRoute's will only `+`handle cross-origin requests if they match the entire URL.`)}return}return o.slice(1)};super(a,o,s)}}class h{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(e=>{const{request:t}=e;const r=this.handleRequest({request:t,event:e});if(r){e.respondWith(r)}}))}addCacheListener(){self.addEventListener("message",(e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data;{r.logger.debug(`Caching URLs from the window`,t.urlsToCache)}const o=Promise.all(t.urlsToCache.map((e=>{if(typeof e==="string"){e=[e]}const t=new Request(...e);return this.handleRequest({request:t})})));e.waitUntil(o);if(e.ports&&e.ports[0]){o.then((()=>e.ports[0].postMessage(true)))}}}))}handleRequest({request:e,event:o}){{t.assert.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"})}const a=new URL(e.url,location.href);if(!a.protocol.startsWith("http")){{r.logger.debug(`Workbox Router only supports URLs that start with 'http'.`)}return}const{params:n,route:i}=this.findMatchingRoute({url:a,request:e,event:o});let u=i&&i.handler;const l=[];{if(u){l.push([`Found a route to handle this request:`,i]);if(n){l.push([`Passing the following params to the route's handler:`,n])}}}if(!u&&this._defaultHandler){{l.push(`Failed to find a matching route. Falling `+`back to the default handler.`)}u=this._defaultHandler}if(!u){{r.logger.debug(`No route found for: ${s.getFriendlyURL(a)}`)}return}{r.logger.groupCollapsed(`Router is responding to: ${s.getFriendlyURL(a)}`);l.forEach((e=>{if(Array.isArray(e)){r.logger.log(...e)}else{r.logger.log(e)}}));r.logger.groupEnd()}let c;try{c=u.handle({url:a,request:e,event:o,params:n})}catch(e){c=Promise.reject(e)}if(c instanceof Promise&&this._catchHandler){c=c.catch((t=>{{r.logger.groupCollapsed(`Error thrown when responding to: `+` ${s.getFriendlyURL(a)}. Falling back to Catch Handler.`);r.logger.error(`Error thrown by:`,i);r.logger.error(t);r.logger.groupEnd()}return this._catchHandler.handle({url:a,request:e,event:o})}))}return c}findMatchingRoute({url:e,request:r,event:o}){{t.assert.isInstance(e,URL,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.url"});t.assert.isInstance(r,Request,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.request"})}const s=this._routes.get(r.method)||[];for(const t of s){let s;const a=t.match({url:e,request:r,event:o});if(a){s=a;if(Array.isArray(a)&&a.length===0){s=undefined}else if(a.constructor===Object&&Object.keys(a).length===0){s=undefined}else if(typeof a==="boolean"){s=undefined}return{route:t,params:s}}}return{}}setDefaultHandler(e){this._defaultHandler=i(e)}setCatchHandler(e){this._catchHandler=i(e)}registerRoute(e){{t.assert.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"});t.assert.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"});t.assert.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"});t.assert.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"});t.assert.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"})}if(!this._routes.has(e.method)){this._routes.set(e.method,[])}this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method)){throw new o.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method})}const t=this._routes.get(e.method).indexOf(e);if(t>-1){this._routes.get(e.method).splice(t,1)}else{throw new o.WorkboxError("unregister-route-route-not-registered")}}}let d;const m=()=>{if(!d){d=new h;d.addFetchListener();d.addCacheListener()}return d};function g(e,t,s){let a;if(typeof e==="string"){const n=new URL(e,location.href);{if(!(e.startsWith("/")||e.startsWith("http"))){throw new o.WorkboxError("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"})}const t=e.startsWith("http")?n.pathname:e;const s="[*:?+]";if(new RegExp(`${s}`).exec(t)){r.logger.debug(`The '$capture' parameter contains an Express-style wildcard `+`character (${s}). Strings are now always interpreted as `+`exact matches; use a RegExp for partial or wildcard matches.`)}}const i=({url:t})=>{{if(t.pathname===n.pathname&&t.origin!==n.origin){r.logger.debug(`${e} only partially matches the cross-origin URL `+`${t}. This route will only handle cross-origin requests `+`if they match the entire URL.`)}}return t.href===n.href};a=new u(i,t,s)}else if(e instanceof RegExp){a=new c(e,t,s)}else if(typeof e==="function"){a=new u(e,t,s)}else if(e instanceof u){a=e}else{throw new o.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"})}const n=m();n.registerRoute(a);return a}function f(e){const t=m();t.setCatchHandler(e)}function p(e){const t=m();t.setDefaultHandler(e)}e.NavigationRoute=l;e.RegExpRoute=c;e.Route=u;e.Router=h;e.registerRoute=g;e.setCatchHandler=f;e.setDefaultHandler=p;return e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);