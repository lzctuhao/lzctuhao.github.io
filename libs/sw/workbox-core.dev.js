this.workbox=this.workbox||{};this.workbox.core=function(e){"use strict";try{self["workbox:core:5.1.2"]&&_()}catch(e){}const t=(()=>{if(!("__WB_DISABLE_DEV_LOGS"in self)){self.__WB_DISABLE_DEV_LOGS=false}let e=false;const t={debug:`#7f8c8d`,log:`#2ecc71`,warn:`#f39c12`,error:`#c0392b`,groupCollapsed:`#3498db`,groupEnd:null};const r=function(r,n){if(self.__WB_DISABLE_DEV_LOGS){return}if(r==="groupCollapsed"){if(/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){console[r](...n);return}}const a=[`background: ${t[r]}`,`border-radius: 0.5em`,`color: white`,`font-weight: bold`,`padding: 2px 0.5em`];const s=e?[]:["%cworkbox",a.join(";")];console[r](...s,...n);if(r==="groupCollapsed"){e=true}if(r==="groupEnd"){e=false}};const n={};const a=Object.keys(t);for(const e of a){const t=e;n[t]=(...e)=>{r(t,e)}}return n})();const r={"invalid-value":({paramName:e,validValueDescription:t,value:r})=>{if(!e||!t){throw new Error(`Unexpected input to 'invalid-value' error.`)}return`The '${e}' parameter was given a value with an `+`unexpected value. ${t} Received a value of `+`${JSON.stringify(r)}.`},"not-in-sw":({moduleName:e})=>{if(!e){throw new Error(`Unexpected input to 'not-in-sw' error.`)}return`The '${e}' must be used in a service worker.`},"not-an-array":({moduleName:e,className:t,funcName:r,paramName:n})=>{if(!e||!t||!r||!n){throw new Error(`Unexpected input to 'not-an-array' error.`)}return`The parameter '${n}' passed into `+`'${e}.${t}.${r}()' must be an array.`},"incorrect-type":({expectedType:e,paramName:t,moduleName:r,className:n,funcName:a})=>{if(!e||!t||!r||!a){throw new Error(`Unexpected input to 'incorrect-type' error.`)}return`The parameter '${t}' passed into `+`'${r}.${n?n+".":""}`+`${a}()' must be of type ${e}.`},"incorrect-class":({expectedClass:e,paramName:t,moduleName:r,className:n,funcName:a,isReturnValueProblem:s})=>{if(!e||!r||!a){throw new Error(`Unexpected input to 'incorrect-class' error.`)}if(s){return`The return value from `+`'${r}.${n?n+".":""}${a}()' `+`must be an instance of class ${e.name}.`}return`The parameter '${t}' passed into `+`'${r}.${n?n+".":""}${a}()' `+`must be an instance of class ${e.name}.`},"missing-a-method":({expectedMethod:e,paramName:t,moduleName:r,className:n,funcName:a})=>{if(!e||!t||!r||!n||!a){throw new Error(`Unexpected input to 'missing-a-method' error.`)}return`${r}.${n}.${a}() expected the `+`'${t}' parameter to expose a '${e}' method.`},"add-to-cache-list-unexpected-type":({entry:e})=>`An unexpected entry was passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' The entry `+`'${JSON.stringify(e)}' isn't supported. You must supply an array of `+`strings with one or more characters, objects with a url property or `+`Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:e,secondEntry:t})=>{if(!e||!t){throw new Error(`Unexpected input to `+`'add-to-cache-list-duplicate-entries' error.`)}return`Two of the entries passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' had the URL `+`${e._entryId} but different revision details. Workbox is `+`is unable to cache and version the asset correctly. Please remove one `+`of the entries.`},"plugin-error-request-will-fetch":({thrownError:e})=>{if(!e){throw new Error(`Unexpected input to `+`'plugin-error-request-will-fetch', error.`)}return`An error was thrown by a plugins 'requestWillFetch()' method. `+`The thrown error message was: '${e.message}'.`},"invalid-cache-name":({cacheNameId:e,value:t})=>{if(!e){throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`)}return`You must provide a name containing at least one character for `+`setCacheDetails({${e}: '...'}). Received a value of `+`'${JSON.stringify(t)}'`},"unregister-route-but-not-found-with-method":({method:e})=>{if(!e){throw new Error(`Unexpected input to `+`'unregister-route-but-not-found-with-method' error.`)}return`The route you're trying to unregister was not  previously `+`registered for the method type '${e}'.`},"unregister-route-route-not-registered":()=>`The route you're trying to unregister was not previously `+`registered.`,"queue-replay-failed":({name:e})=>`Replaying the background sync queue '${e}' failed.`,"duplicate-queue-name":({name:e})=>`The Queue name '${e}' is already being used. `+`All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:e,paramName:t})=>`The '${e}()' method can only be used when the `+`'${t}' is used in the constructor.`,"unsupported-route-type":({moduleName:e,className:t,funcName:r,paramName:n})=>`The supplied '${n}' parameter was an unsupported type. `+`Please check the docs for ${e}.${t}.${r} for `+`valid input types.`,"not-array-of-class":({value:e,expectedClass:t,moduleName:r,className:n,funcName:a,paramName:s})=>`The supplied '${s}' parameter must be an array of `+`'${t}' objects. Received '${JSON.stringify(e)},'. `+`Please check the call to ${r}.${n}.${a}() `+`to fix the issue.`,"max-entries-or-age-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.maxEntries or config.maxAgeSeconds`+`in ${e}.${t}.${r}`,"statuses-or-headers-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.statuses or config.headers`+`in ${e}.${t}.${r}`,"invalid-string":({moduleName:e,funcName:t,paramName:r})=>{if(!r||!e||!t){throw new Error(`Unexpected input to 'invalid-string' error.`)}return`When using strings, the '${r}' parameter must start with `+`'http' (for cross-origin matches) or '/' (for same-origin matches). `+`Please see the docs for ${e}.${t}() for `+`more info.`},"channel-name-required":()=>`You must provide a channelName to construct a `+`BroadcastCacheUpdate instance.`,"invalid-responses-are-same-args":()=>`The arguments passed into responsesAreSame() appear to be `+`invalid. Please ensure valid Responses are used.`,"expire-custom-caches-only":()=>`You must provide a 'cacheName' property when using the `+`expiration plugin with a runtime caching strategy.`,"unit-must-be-bytes":({normalizedRangeHeader:e})=>{if(!e){throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`)}return`The 'unit' portion of the Range header must be set to 'bytes'. `+`The Range header provided was "${e}"`},"single-range-only":({normalizedRangeHeader:e})=>{if(!e){throw new Error(`Unexpected input to 'single-range-only' error.`)}return`Multiple ranges are not supported. Please use a  single start `+`value, and optional end value. The Range header provided was `+`"${e}"`},"invalid-range-values":({normalizedRangeHeader:e})=>{if(!e){throw new Error(`Unexpected input to 'invalid-range-values' error.`)}return`The Range header is missing both start and end values. At least `+`one of those values is needed. The Range header provided was `+`"${e}"`},"no-range-header":()=>`No Range header was found in the Request provided.`,"range-not-satisfiable":({size:e,start:t,end:r})=>`The start (${t}) and end (${r}) values in the Range are `+`not satisfiable by the cached response, which is ${e} bytes.`,"attempt-to-cache-non-get-request":({url:e,method:t})=>`Unable to cache '${e}' because it is a '${t}' request and `+`only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:e})=>`There was an attempt to cache '${e}' but the response was not `+`defined.`,"no-response":({url:e,error:t})=>{let r=`The strategy could not generate a response for '${e}'.`;if(t){r+=` The underlying error is ${t}.`}return r},"bad-precaching-response":({url:e,status:t})=>`The precaching request for '${e}' failed with an HTTP `+`status of ${t}.`,"non-precached-url":({url:e})=>`createHandlerBoundToURL('${e}') was called, but that URL is `+`not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:e})=>`Two of the entries passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' had the URL `+`${e} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:e,url:t})=>`Unable to find a precached response in ${e} for ${t}.`};const n=(e,t={})=>{const n=r[e];if(!n){throw new Error(`Unable to find message for code '${e}'.`)}return n(t)};const a=n;class s extends Error{constructor(e,t){const r=a(e,t);super(r);this.name=e;this.details=t}}const o=e=>{if(!("ServiceWorkerGlobalScope"in self)){throw new s("not-in-sw",{moduleName:e})}};const i=(e,t)=>{if(!Array.isArray(e)){throw new s("not-an-array",t)}};const c=(e,t,r)=>{const n=typeof e[t];if(n!=="function"){r["expectedMethod"]=t;throw new s("missing-a-method",r)}};const u=(e,t,r)=>{if(typeof e!==t){r["expectedType"]=t;throw new s("incorrect-type",r)}};const l=(e,t,r)=>{if(!(e instanceof t)){r["expectedClass"]=t;throw new s("incorrect-class",r)}};const d=(e,t,r)=>{if(!t.includes(e)){r["validValueDescription"]=`Valid values are ${JSON.stringify(t)}.`;throw new s("invalid-value",r)}};const h=(e,t,r)=>{const n=new s("not-array-of-class",r);if(!Array.isArray(e)){throw n}for(const r of e){if(!(r instanceof t)){throw n}}};const p={hasMethod:c,isArray:i,isInstance:l,isOneOf:d,isSWEnv:o,isType:u,isArrayOfClass:h};const f=new Set;function m(e){{p.isType(e,"function",{moduleName:"workbox-core",funcName:"register",paramName:"callback"})}f.add(e);{t.log("Registered a callback to respond to quota errors.",e)}}const g={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration!=="undefined"?registration.scope:""};const w=e=>[g.prefix,e,g.suffix].filter((e=>e&&e.length>0)).join("-");const y=e=>{for(const t of Object.keys(g)){e(t)}};const b={updateDetails:e=>{y((t=>{if(typeof e[t]==="string"){g[t]=e[t]}}))},getGoogleAnalyticsName:e=>e||w(g.googleAnalytics),getPrecacheName:e=>e||w(g.precache),getPrefix:()=>g.prefix,getRuntimeName:e=>e||w(g.runtime),getSuffix:()=>g.suffix};async function v(){{t.log(`About to run ${f.size} `+`callbacks to clean up caches.`)}for(const e of f){await e();{t.log(e,"is complete.")}}{t.log("Finished running callbacks.")}}const N=e=>{const t=new URL(String(e),location.href);return t.href.replace(new RegExp(`^${location.origin}`),"")};const $={filter:(e,t)=>e.filter((e=>t in e))};const x=async({request:e,mode:t,plugins:r=[]})=>{const n=$.filter(r,"cacheKeyWillBeUsed");let a=e;for(const e of n){a=await e["cacheKeyWillBeUsed"].call(e,{mode:t,request:a});if(typeof a==="string"){a=new Request(a)}{p.isInstance(a,Request,{moduleName:"Plugin",funcName:"cacheKeyWillBeUsed",isReturnValueProblem:true})}}return a};const R=async({request:e,response:r,event:n,plugins:a=[]})=>{let s=r;let o=false;for(const t of a){if("cacheWillUpdate"in t){o=true;const r=t["cacheWillUpdate"];s=await r.call(t,{request:e,response:s,event:n});{if(s){p.isInstance(s,Response,{moduleName:"Plugin",funcName:"cacheWillUpdate",isReturnValueProblem:true})}}if(!s){break}}}if(!o){{if(s){if(s.status!==200){if(s.status===0){t.warn(`The response for '${e.url}' is an opaque `+`response. The caching strategy that you're using will not `+`cache opaque responses by default.`)}else{t.debug(`The response for '${e.url}' returned `+`a status code of '${r.status}' and won't be cached as a `+`result.`)}}}}s=s&&s.status===200?s:undefined}return s?s:null};const q=async({cacheName:e,request:r,event:n,matchOptions:a,plugins:s=[]})=>{const o=await self.caches.open(e);const i=await x({plugins:s,request:r,mode:"read"});let c=await o.match(i,a);{if(c){t.debug(`Found a cached response in '${e}'.`)}else{t.debug(`No cached response found in '${e}'.`)}}for(const t of s){if("cachedResponseWillBeUsed"in t){const r=t["cachedResponseWillBeUsed"];c=await r.call(t,{cacheName:e,event:n,matchOptions:a,cachedResponse:c,request:i});{if(c){p.isInstance(c,Response,{moduleName:"Plugin",funcName:"cachedResponseWillBeUsed",isReturnValueProblem:true})}}}}return c};const T=async({cacheName:e,request:r,response:n,event:a,plugins:o=[],matchOptions:i})=>{{if(r.method&&r.method!=="GET"){throw new s("attempt-to-cache-non-get-request",{url:N(r.url),method:r.method})}}const c=await x({plugins:o,request:r,mode:"write"});if(!n){{t.error(`Cannot cache non-existent response for `+`'${N(c.url)}'.`)}throw new s("cache-put-with-no-response",{url:N(c.url)})}const u=await R({event:a,plugins:o,response:n,request:c});if(!u){{t.debug(`Response '${N(c.url)}' will `+`not be cached.`,u)}return}const l=await self.caches.open(e);const d=$.filter(o,"cacheDidUpdate");const h=d.length>0?await q({cacheName:e,matchOptions:i,request:c}):null;{t.debug(`Updating the '${e}' cache with a new Response for `+`${N(c.url)}.`)}try{await l.put(c,u)}catch(e){if(e.name==="QuotaExceededError"){await v()}throw e}for(const t of d){await t["cacheDidUpdate"].call(t,{cacheName:e,event:a,oldResponse:h,newResponse:u,request:c})}};const E={put:T,match:q};let k;function U(){if(k===undefined){try{new ReadableStream({start(){}});k=true}catch(e){k=false}}return k}let A;function P(){if(A===undefined){const e=new Response("");if("body"in e){try{new Response(e.body);A=true}catch(e){A=false}}A=false}return A}function S(e){e.then((()=>{}))}class D{constructor(e,t,{onupgradeneeded:r,onversionchange:n}={}){this._db=null;this._name=e;this._version=t;this._onupgradeneeded=r;this._onversionchange=n||(()=>this.close())}get db(){return this._db}async open(){if(this._db)return;this._db=await new Promise(((e,t)=>{let r=false;setTimeout((()=>{r=true;t(new Error("The open request was blocked and timed out"))}),this.OPEN_TIMEOUT);const n=indexedDB.open(this._name,this._version);n.onerror=()=>t(n.error);n.onupgradeneeded=e=>{if(r){n.transaction.abort();n.result.close()}else if(typeof this._onupgradeneeded==="function"){this._onupgradeneeded(e)}};n.onsuccess=()=>{const t=n.result;if(r){t.close()}else{t.onversionchange=this._onversionchange.bind(this);e(t)}}}));return this}async getKey(e,t){return(await this.getAllKeys(e,t,1))[0]}async getAll(e,t,r){return await this.getAllMatching(e,{query:t,count:r})}async getAllKeys(e,t,r){const n=await this.getAllMatching(e,{query:t,count:r,includeKeys:true});return n.map((e=>e.key))}async getAllMatching(e,{index:t,query:r=null,direction:n="next",count:a,includeKeys:s=false}={}){return await this.transaction([e],"readonly",((o,i)=>{const c=o.objectStore(e);const u=t?c.index(t):c;const l=[];const d=u.openCursor(r,n);d.onsuccess=()=>{const e=d.result;if(e){l.push(s?e:e.value);if(a&&l.length>=a){i(l)}else{e.continue()}}else{i(l)}}}))}async transaction(e,t,r){await this.open();return await new Promise(((n,a)=>{const s=this._db.transaction(e,t);s.onabort=()=>a(s.error);s.oncomplete=()=>n();r(s,(e=>n(e)))}))}async _call(e,t,r,...n){const a=(r,a)=>{const s=r.objectStore(t);const o=s[e].apply(s,n);o.onsuccess=()=>a(o.result)};return await this.transaction([t],r,a)}close(){if(this._db){this._db.close();this._db=null}}}D.prototype.OPEN_TIMEOUT=2e3;const W={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[e,t]of Object.entries(W)){for(const r of t){if(r in IDBObjectStore.prototype){D.prototype[r]=async function(t,...n){return await this._call(r,t,e,...n)}}}}class C{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e;this.reject=t}))}}const O=async e=>{await new Promise(((t,r)=>{const n=indexedDB.deleteDatabase(e);n.onerror=()=>{r(n.error)};n.onblocked=()=>{r(new Error("Delete blocked"))};n.onsuccess=()=>{t()}}))};const B=async({request:e,fetchOptions:r,event:n,plugins:a=[]})=>{if(typeof e==="string"){e=new Request(e)}if(n instanceof FetchEvent&&n.preloadResponse){const r=await n.preloadResponse;if(r){{t.log(`Using a preloaded navigation response for `+`'${N(e.url)}'`)}return r}}{p.isInstance(e,Request,{paramName:"request",expectedClass:Request,moduleName:"workbox-core",className:"fetchWrapper",funcName:"wrappedFetch"})}const o=$.filter(a,"fetchDidFail");const i=o.length>0?e.clone():null;try{for(const t of a){if("requestWillFetch"in t){const r=t["requestWillFetch"];const a=e.clone();e=await r.call(t,{request:a,event:n});if("dev"!=="production"){if(e){p.isInstance(e,Request,{moduleName:"Plugin",funcName:"cachedResponseWillBeUsed",isReturnValueProblem:true})}}}}}catch(e){throw new s("plugin-error-request-will-fetch",{thrownError:e})}const c=e.clone();try{let s;if(e.mode==="navigate"){s=await fetch(e)}else{s=await fetch(e,r)}if("dev"!=="production"){t.debug(`Network request for `+`'${N(e.url)}' returned a response with `+`status '${s.status}'.`)}for(const e of a){if("fetchDidSucceed"in e){s=await e["fetchDidSucceed"].call(e,{event:n,request:c,response:s});if("dev"!=="production"){if(s){p.isInstance(s,Response,{moduleName:"Plugin",funcName:"fetchDidSucceed",isReturnValueProblem:true})}}}}return s}catch(r){{t.error(`Network request for `+`'${N(e.url)}' threw an error.`,r)}for(const e of o){await e["fetchDidFail"].call(e,{error:r,event:n,originalRequest:i.clone(),request:c.clone()})}throw r}};const I={fetch:B};function L(e){return new Promise((t=>setTimeout(t,e)))}const j=2e3;async function F(e){if(!e){return}let t=await self.clients.matchAll({type:"window"});const r=new Set(t.map((e=>e.id)));let n;const a=performance.now();while(performance.now()-a<j){t=await self.clients.matchAll({type:"window"});n=t.find((t=>{if(e){return t.id===e}else{return!r.has(t.id)}}));if(n){break}await L(100)}return n}var V=Object.freeze({__proto__:null,assert:p,cacheNames:b,cacheWrapper:E,canConstructReadableStream:U,canConstructResponseFromBodyStream:P,dontWaitFor:S,DBWrapper:D,Deferred:C,deleteDatabase:O,executeQuotaErrorCallbacks:v,fetchWrapper:I,getFriendlyURL:N,logger:t,resultingClientExists:F,timeout:L,WorkboxError:s});const K={get googleAnalytics(){return b.getGoogleAnalyticsName()},get precache(){return b.getPrecacheName()},get prefix(){return b.getPrefix()},get runtime(){return b.getRuntimeName()},get suffix(){return b.getSuffix()}};async function M(e,t){const r=e.clone();const n={headers:new Headers(r.headers),status:r.status,statusText:r.statusText};const a=t?t(n):n;const s=P()?r.body:await r.blob();return new Response(s,a)}function G(){self.addEventListener("activate",(()=>self.clients.claim()))}function z(e){{Object.keys(e).forEach((t=>{p.isType(e[t],"string",{moduleName:"workbox-core",funcName:"setCacheNameDetails",paramName:`details.${t}`})}));if("precache"in e&&e["precache"].length===0){throw new s("invalid-cache-name",{cacheNameId:"precache",value:e["precache"]})}if("runtime"in e&&e["runtime"].length===0){throw new s("invalid-cache-name",{cacheNameId:"runtime",value:e["runtime"]})}if("googleAnalytics"in e&&e["googleAnalytics"].length===0){throw new s("invalid-cache-name",{cacheNameId:"googleAnalytics",value:e["googleAnalytics"]})}}b.updateDetails(e)}function H(){self.addEventListener("install",(()=>self.skipWaiting()))}e._private=V;e.cacheNames=K;e.clientsClaim=G;e.copyResponse=M;e.registerQuotaErrorCallback=m;e.setCacheNameDetails=z;e.skipWaiting=H;return e}({});