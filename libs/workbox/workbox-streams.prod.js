this.workbox=this.workbox||{},this.workbox.streams=function(e,t,n,r){"use strict";try{self["workbox:streams:7.2.0"]&&_()}catch(e){}function o(e){const r=e.map((e=>Promise.resolve(e).then((e=>function(e){if(e instanceof Response){if(e.body)return e.body.getReader();throw new n.WorkboxError("opaque-streams-source",{type:e.type})}return e instanceof ReadableStream?e.getReader():new Response(e).body.getReader()}(e))))),o=new t.Deferred;let s=0;const a=new ReadableStream({pull(e){return r[s].then((e=>e instanceof ReadableStreamDefaultReader?e.read():void 0)).then((t=>{if(null==t?void 0:t.done)return s++,s>=r.length?(e.close(),void o.resolve()):this.pull(e);e.enqueue(null==t?void 0:t.value)})).catch((e=>{throw o.reject(e),e}))},cancel(){o.resolve()}});return{done:o.promise,stream:a}}function s(e={}){const t=new Headers(e);return t.has("content-type")||t.set("content-type","text/html"),t}function a(e,t){const{done:n,stream:r}=o(e),a=s(t);return{done:n,response:new Response(r,{headers:a})}}function c(){return r.canConstructReadableStream()}return e.concatenate=o,e.concatenateToResponse=a,e.isSupported=c,e.strategy=function(e,t){return async({event:n,request:r,url:o,params:u})=>{const i=e.map((e=>Promise.resolve(e({event:n,request:r,url:o,params:u}))));if(c()){const{done:e,response:r}=a(i,t);return n&&n.waitUntil(e),r}const l=i.map((async e=>{const t=await e;return t instanceof Response?t.blob():new Response(t).blob()})),p=await Promise.all(l),d=s(t);return new Response(new Blob(p),{headers:d})}},e}({},workbox.core._private,workbox.core._private,workbox.core._private);